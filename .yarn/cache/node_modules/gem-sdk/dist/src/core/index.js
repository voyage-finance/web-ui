"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Gem = void 0;
const requestHandler_1 = require("../helpers/requestHandler");
const bignumber_js_1 = require("bignumber.js");
const erc20Abi_1 = require("../abi/erc20Abi");
const contants_1 = require("./contants");
class Gem {
    constructor(provider) {
        this.Web3Provider = provider;
    }
    getNftData({ nftAddress, nftId, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const getNftData = yield requestHandler_1.default.get(`${contants_1.GEM_API}/asset/${nftAddress}/${nftId}`, {});
            if (getNftData.status === 200) {
                return getNftData.data;
            }
            else {
                return { error: "gem api error" };
            }
        });
    }
    getCollectionData({ sort = contants_1.SORT_FILTER, filters = {}, limit = 10, fields = contants_1.COLLECTION_FIELDS, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield requestHandler_1.default.post(`${contants_1.GEM_API}/collections`, {
                sort,
                filters,
                limit,
                fields,
            });
            if (response.status === 200) {
                return response.data;
            }
            else {
                return { error: "gem api error" };
            }
        });
    }
    getAssetData({ filters, // { "field name": "asc" or "desc"}, you can sort by multiple fields
    sort, // { "field name": 1 (include field) or -1 (ignore field) }
    // ideally ONLY request the fields you want to reduce bandwidth usage and response time
    fields = contants_1.ASSETS_FIELDS, limit, // specifies the (max) number of responses (default: 20)
    offset, // specifies the number of results to skip from start
    status, // values can be "all" or "buy_now" (default: "buy_now")
    markets, // specify the market orders you want. If left blank, it will give all market orders.
     }) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield requestHandler_1.default.post(`${contants_1.GEM_API}/assets`, {
                filters,
                sort,
                fields,
                limit,
                offset,
                status,
                markets,
            });
            if (response.status === 200) {
                return response.data;
            }
            else {
                return { error: "gem api error" };
            }
        });
    }
    getRoute(senderAddress, paymentToken, buyDetails) {
        return __awaiter(this, void 0, void 0, function* () {
            var response = yield requestHandler_1.default.post(`${contants_1.GEM_API}/route`, {
                "sender": senderAddress,
                "balanceToken": paymentToken,
                "sell": [],
                "buy": buyDetails
            });
            if (response.status === 200) {
                return response.data;
            }
            else {
                return { error: "gem api error" };
            }
        });
    }
    batchBuyNfts(senderAddress, paymentToken, buyDetails) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        return __awaiter(this, void 0, void 0, function* () {
            //@ts-ignore
            let chainId = yield this.Web3Provider.eth.net.getId();
            if (chainId !== 1) {
                throw new Error("Chaind id not supported");
            }
            var response = yield requestHandler_1.default.post(`${contants_1.GEM_API}/route`, {
                "sender": senderAddress,
                "balanceToken": paymentToken,
                "sell": [],
                "buy": buyDetails
            });
            if (response.status === 200) {
                if (!((_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.transaction)) {
                    throw new Error("this item is not for buy you can bid on it");
                }
                const valueOfEth = ((_b = response === null || response === void 0 ? void 0 : response.data) === null || _b === void 0 ? void 0 : _b.value) || ((_d = (_c = response === null || response === void 0 ? void 0 : response.data) === null || _c === void 0 ? void 0 : _c.amountToBalance) === null || _d === void 0 ? void 0 : _d.hex) ? ((_e = response === null || response === void 0 ? void 0 : response.data) === null || _e === void 0 ? void 0 : _e.value) || new bignumber_js_1.BigNumber((_g = (_f = response === null || response === void 0 ? void 0 : response.data) === null || _f === void 0 ? void 0 : _f.amountToBalance) === null || _g === void 0 ? void 0 : _g.hex) : 0;
                const gemContractAddress = response.data.contractAddress;
                let EthRequired = new bignumber_js_1.BigNumber(valueOfEth.toString());
                if (paymentToken !== "0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee") {
                    let amountForAllowance = ((_j = (_h = response === null || response === void 0 ? void 0 : response.data) === null || _h === void 0 ? void 0 : _h.amountToBalance) === null || _j === void 0 ? void 0 : _j.hex) ? new bignumber_js_1.BigNumber(response.data.amountToBalance.hex) : 0;
                    // @ts-ignore
                    amountForAllowance = new bignumber_js_1.BigNumber(amountForAllowance.toString());
                    // @ts-ignore
                    const Erc20Contract = new this.Web3Provider.eth.Contract(erc20Abi_1.CanonicalWETH, paymentToken);
                    let allowanceForGem = yield Erc20Contract.methods.allowance(senderAddress, gemContractAddress).call();
                    allowanceForGem = new bignumber_js_1.BigNumber(allowanceForGem.toString());
                    let balanceOfToken = yield Erc20Contract.methods.balanceOf(senderAddress).call();
                    balanceOfToken = new bignumber_js_1.BigNumber(balanceOfToken.toString());
                    if (!balanceOfToken.isGreaterThanOrEqualTo(amountForAllowance)) {
                        throw new Error("low balance of payment token");
                    }
                    if (!allowanceForGem.isGreaterThanOrEqualTo(amountForAllowance)) {
                        try {
                            yield Erc20Contract.methods.approve(gemContractAddress, contants_1.MAX_UINT).send({ from: senderAddress });
                        }
                        catch (e) {
                            throw new Error(e);
                        }
                    }
                }
                else {
                    // @ts-ignore
                    let ethBalance = yield this.Web3Provider.eth.getBalance(senderAddress);
                    ethBalance = new bignumber_js_1.BigNumber(ethBalance.toString());
                    if (!ethBalance.isGreaterThanOrEqualTo(EthRequired)) {
                        throw new Error("User have Low Eth Balance");
                    }
                }
                // @ts-ignore
                const gas = yield this.Web3Provider.eth.estimateGas({
                    from: senderAddress,
                    to: response.data.contractAddress,
                    value: Number(EthRequired),
                    data: response.data.transaction,
                });
                // @ts-ignore
                const transactionHash = this.Web3Provider.eth.sendTransaction({
                    from: senderAddress,
                    to: response.data.contractAddress,
                    value: Number(EthRequired),
                    data: response.data.transaction,
                    gas
                });
                return transactionHash;
            }
            else {
                return { error: "gem api error" };
            }
        });
    }
    bid() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    listNfts() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    sellNfts() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
}
exports.Gem = Gem;
//# sourceMappingURL=index.js.map